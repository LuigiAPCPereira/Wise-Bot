Discord.js RPG Bot Development Guidelines - Factual and Official Este documento fornece diretrizes e melhores práticas fatuais e baseadas na documentação oficial para o desenvolvimento de bots de RPG robustos usando o stack Discord.js v14+ + Prisma + Supabase. O foco é na precisão técnica e na aderência estrita às APIs e funcionalidades existentes.

Foco e Escopo Foco Principal: Desenvolvimento de bots de RPG interativos e escaláveis para Discord. Tecnologias: Discord.js v14+, Prisma ORM, Supabase (PostgreSQL, Auth, Realtime). Prioridade: Precisão factual, alinhamento com a documentação oficial e práticas pragmáticas de desenvolvimento. Stack Tecnológico Oficial Discord.js v14+: Biblioteca para interação com a API do Discord. Prisma: ORM para gerenciamento de banco de dados. Supabase: Backend-as-a-Service (BaaS) para banco de dados, autenticação e funcionalidades em tempo real.

Discord.js Stack 1.1. Componentes de Mensagem (Message Components) Os componentes de mensagem são elementos interativos que podem ser adicionados às mensagens do Discord, como botões e menus de seleção. Eles permitem criar interfaces de usuário ricas e dinâmicas diretamente nas mensagens. [1] Tipos de Componentes A API do Discord define os seguintes tipos de componentes de mensagem:

Action Row (Tipo 1): Um contêiner para exibir uma linha de componentes interativos. Uma mensagem pode ter no máximo 5 Action Rows. [2] Button (Tipo 2): Um botão clicável. Deve ser colocado dentro de uma Action Row. [3] String Select (Tipo 3): Um menu de seleção para escolher entre opções de texto predefinidas. Deve ser colocado dentro de uma Action Row. [4] Text Input (Tipo 4): Um campo de entrada de texto. Usado em Modals. [5] User Select (Tipo 5): Um menu de seleção para usuários. [6] Role Select (Tipo 6): Um menu de seleção para cargos. [7] Mentionable Select (Tipo 7): Um menu de seleção para menções (usuários e cargos). [8] Channel Select (Tipo 8): Um menu de seleção para canais. [9] Uso de content e embeds com Componentes É importante notar que os campos content (o texto da mensagem) e embeds (mensagens ricas com formatação) funcionam em conjunto com os componentes de mensagem. A documentação oficial do Discord não indica que o uso de componentes desativa ou substitui content ou embeds. Pelo contrário, eles são frequentemente usados em combinação para fornecer contexto textual e visual para as interações. [10]

Limites Uma mensagem pode conter no máximo 5 Action Rows. [11] Cada Action Row pode conter no máximo 5 botões ou 1 menu de seleção. [12] Interações Quando um usuário interage com um componente (e.g., clica em um botão), uma interação é enviada ao seu bot. É crucial responder a essas interações dentro de 3 segundos para evitar que a interação expire. As respostas podem ser mensagens, atualizações de mensagens ou modais. [13]

1.2. Melhores Práticas com Discord.js Para garantir a robustez, escalabilidade e manutenibilidade de um bot de RPG, é essencial aderir às melhores práticas de desenvolvimento com Discord.js v14+.

Arquitetura Modular Uma arquitetura modular é fundamental para bots complexos. Recomenda-se a separação clara de responsabilidades:

Event Handlers: Módulos dedicados para lidar com eventos do Discord (e.g., interactionCreate, ready). [14] Command Handlers: Lógica para processar comandos (slash commands, context menus). [15] Component Handlers: Lógica para responder a interações de componentes (botões, menus de seleção). [16] Performance e Escalabilidade Caching: Utilize o sistema de cache do Discord.js de forma eficiente para reduzir chamadas desnecessárias à API do Discord. Gerencie o cache para evitar consumo excessivo de memória. [17] Sharding: Para bots que servem um grande número de guilds (acima de 2.500), o sharding é indispensável para distribuir a carga e manter a responsividade. [18] Segurança Validação de Entrada: Valide todas as entradas do usuário para prevenir vulnerabilidades. [19] Rate Limiting: O Discord.js lida com o rate limiting da API do Discord, mas considere implementar rate limiting adicional para comandos específicos do seu bot. [20] Validação de Permissões: Sempre verifique as permissões do usuário e do bot antes de executar ações sensíveis. [21] Tratamento de Erros e Logging Tratamento de Erros: Implemente blocos try-catch para operações que podem falhar e forneça feedback útil. [22] Logging: Utilize uma biblioteca de logging (e.g., Pino, Winston) para registrar eventos, erros e informações de depuração. [23] 1.3. Design de Embeds Embeds são elementos visuais para apresentar informações ricas. Eles funcionam em conjunto com os componentes de mensagem. [24]

Layouts e Campos Dinâmicos Estrutura de Informação: Organize informações hierarquicamente com títulos, descrições, campos e footers. [25] Campos Dinâmicos: Popule campos com dados do jogo (estatísticas, inventário) buscando do banco de dados. [26] Cores e Ícones: Use cores e ícones para categorizar e melhorar a estética. [27] Timestamps: Inclua timestamps para atualizações ou eventos. [28] Interatividade com Componentes Combine embeds com componentes para navegação e interatividade:

Paginação: Use botões para paginar listas longas. [29] Select Menus: Permita filtrar informações ou selecionar opções. [30] Modals: Colete informações complexas do usuário. [31] 1.4. Mensagens Efêmeras e Padrões de Interação Mensagens efêmeras são visíveis apenas para o usuário que as acionou, ideais para feedback instantâneo ou informações privadas. [32]

Uso Apropriado Feedback de Comando: Confirmação de execução ou mensagens de erro. [33] Informações Privadas: Detalhes de inventário, estatísticas de personagem. [34] Interações de Formulário/Modal: Confirmação de submissão ou validação. [35] Para enviar uma mensagem efêmera, inclua a flag MessageFlags.Ephemeral no payload. [36]

Database/Prisma Stack 2.1. Prisma Best Practices Prisma é um ORM que simplifica a interação com o banco de dados, oferecendo type safety e um poderoso sistema de migrações. Schema Design Modelagem de Dados: Defina seus modelos de dados no schema.prisma de forma clara e concisa, refletindo as entidades do seu domínio. [37] Relações: Defina as relações entre os modelos (um-para-um, um-para-muitos, muitos-para-muitos) explicitamente no schema. [38] Tipos Escalare: Utilize os tipos escalares do Prisma (String, Int, Boolean, DateTime, Float, Bytes, Json, Decimal, BigInt). Evite o uso excessivo de @db.

Segurança (Row Level Security - RLS) RLS: Habilite e configure o Row Level Security (RLS) no PostgreSQL para implementar controle de acesso granular aos dados, garantindo que os usuários só possam acessar os dados aos quais têm permissão. [45] Autenticação Supabase Auth: Utilize o Supabase Auth para gerenciar a autenticação de usuários humanos em suas aplicações (web/mobile). Embora o bot Discord use tokens do Discord para sua própria autenticação, o Supabase Auth pode ser usado para associar usuários do Discord a registros no banco de dados e gerenciar seus dados. [46] Real-time Real-time Subscriptions: Use as funcionalidades de real-time do Supabase para notificar o bot sobre mudanças no banco de dados (e.g., atualização de status de personagem, novos itens no inventário). [47] 3. Arquitetura e Padrões de Design 3.1. Arquitetura em Camadas Desacopladas Uma arquitetura em camadas desacopladas promove a separação de preocupações e facilita a manutenibilidade e testabilidade. Um padrão comum é:

Handler: Recebe interações (comandos, botões) e delega ao Service. (// ABSTRAÇÃO SUGERIDA, NÃO NATIVA DA API: Este é um padrão de design comum para organizar a lógica de tratamento de interações, não um termo oficial da API do Discord.) Service: Contém a lógica de negócio principal. Orquestra operações complexas e aplica regras de negócio. (// ABSTRAÇÃO SUGERIDA, NÃO NATIVA DA API: Padrão de design para encapsular a lógica de negócio.) Repository: Abstrai a lógica de acesso a dados. Fornece uma interface para operações de CRUD. (// ABSTRAÇÃO SUGERIDA, NÃO NATIVA DA API: Padrão de design para abstrair a camada de persistência.) Database: A camada de persistência de dados (Prisma/Supabase). [48] 3.2. Fluxo de Dados Unidirecional O fluxo de dados unidirecional é um padrão onde os dados fluem em uma única direção através das camadas da aplicação, aumentando a previsibilidade e facilitando a depuração. (// ABSTRAÇÃO SUGERIDA, NÃO NATIVA DA API: Padrão de arquitetura para gerenciar o estado da aplicação.) [49]

3.3. Padrões de Arquitetura (Hexagonal/Clean Architecture) A Arquitetura Hexagonal (Ports and Adapters) ou Clean Architecture reforçam a separação entre o domínio da aplicação e as preocupações externas (UI, banco de dados, APIs), promovendo a testabilidade e a flexibilidade. (// ABSTRAÇÃO SUGERIDA, NÃO NATIVA DA API: Padrões de arquitetura para promover a separação de preocupações.) [50]

Qualidade de Código (Clean Code) 4.1. Princípios SOLID Os princípios SOLID (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) são diretrizes de design de software que promovem código modular, flexível e testável. (// ABSTRAÇÃO SUGERIDA, NÃO NATIVA DA API: Princípios de engenharia de software aplicáveis a qualquer linguagem orientada a objetos.) [51] 4.2. Outras Práticas de Clean Code Funções Puras: Prefira funções puras sempre que possível para lógica de negócio que não depende de estado externo. [52] Responsabilidade Única: Cada módulo ou classe deve ter uma única responsabilidade bem definida. [53] Nomenclatura Descritiva: Use nomes claros e descritivos para variáveis, funções e classes. [54] Code Smells e Refatoração: Identifique e refatore code smells regularmente para manter a qualidade do código. [55] 5. Testabilidade 5.1. Arquitetura Orientada a Testes Projete sua aplicação com a testabilidade em mente, facilitando a escrita de testes unitários e de integração. [56]

5.2. Mocks e Stubs Utilize mocks e stubs para isolar unidades de código durante os testes, simulando dependências externas. [57]

5.3. Tipos de Testes Testes Unitários: Teste unidades individuais de código (funções, classes) isoladamente. [58] Testes de Integração: Teste a interação entre diferentes módulos ou serviços. [59] 5.4. Cobertura de Código Monitore a cobertura de código para garantir que uma porcentagem adequada do seu código seja testada. [60]

Build/Development Tools Stack 6.1. Vite para Bots Discord (Backend) vite-plugin-node oferece Hot Module Replacement (HMR) para desenvolvimento de bots Discord baseados em Node.js, permitindo que as alterações no código sejam aplicadas sem reiniciar o servidor de desenvolvimento. [61] Configuração e Uso Instalação: Instale vite-plugin-node como dependência de desenvolvimento. npm install -D vite-plugin-node

ou yarn add -D vite-plugin-node ou pnpm add -D vite-plugin-node Configuração do Vite: Adicione o plugin ao seu vite.config.ts ou vite.config.js: // vite.config.ts import { defineConfig } from 'vite'; import { VitePluginNode } from 'vite-plugin-node';

export default defineConfig({ server: { hmr: { overlay: false, }, }, plugins: [ ...VitePluginNode({ adapter: 'express', // ou 'koa', 'nest', 'fastify', 'none' appPath: './src/main.ts', // Caminho para o seu arquivo de entrada principal do bot exportName: 'viteNodeApp', }), ], optimizeDeps: { exclude: ['discord.js', '@prisma/client', 'tsyringe', 'pino'], }, build: { rollupOptions: { external: ['discord.js', '@prisma/client', 'tsyringe', 'pino'], }, }, }); Arquivo de Entrada (src/main.ts ou similar): Seu arquivo de entrada deve exportar a instância da sua aplicação (e.g., o cliente Discord.js). // src/main.ts import { Client, GatewayIntentBits } from 'discord.js';

const client = new Client({ intents: [ GatewayIntentBits.Guilds, GatewayIntentBits.GuildMessages, GatewayIntentBits.MessageContent, ], });

client.on('ready', () => { console.log(Logged in as ${client.user?.tag}!); });

client.login(process.env.DISCORD_TOKEN);

export const viteNodeApp = client; Benefícios do HMR com vite-plugin-node Desenvolvimento Mais Rápido: Alterações no código são refletidas quase instantaneamente. [62] Manutenção de Estado: Preserva o estado da aplicação entre as atualizações. [63] Experiência de Desenvolvedor Aprimorada: Reduz o atrito no desenvolvimento. [64] 7. Documentação 7.1. Documentação Mandatória TSDoc: Utilize TSDoc para documentar o código TypeScript, incluindo @param, @returns, @throws. [65] README.md: Mantenha um README.md estruturado com informações sobre o projeto, instalação, uso e contribuição. [66] Documentação de Arquitetura: Documente as decisões de arquitetura e padrões de design utilizados. [67] Changelog: Mantenha um CHANGELOG.md para registrar todas as alterações significativas. [68] Referências [1] Discord Developer Portal - Message Components [2] Discord Developer Portal - Component Reference [3] Discord Developer Portal - Button Styles [4] Discord Developer Portal - String Select [5] Discord Developer Portal - Text Input [6] Discord Developer Portal - User Select [7] Discord Developer Portal - Role Select [8] Discord Developer Portal - Mentionable Select [9] Discord Developer Portal - Channel Select [10] Discord.js Guide - Message Components [11] Discord Developer Portal - Using Message Components [12] Discord Developer Portal - Using Message Components [13] Discord.js Guide - Component Interactions [14] Discord.js Guide - Event Handling [15] Discord.js Guide - Slash Commands [16] Discord.js Guide - Message Components [17] Discord.js Guide - Caching [18] Discord.js Guide - Sharding [19] OWASP Top 10 - Injection (General security principle, not Discord.js specific) [20] Discord Developer Portal - Rate Limits [21] Discord.js Guide - Permissions [22] Node.js Error Handling Best Practices (General Node.js best practice) [23] Pino Logger / Winston Logger (Examples of logging libraries) [24] Discord.js Guide - Embeds [25] Discord.js Guide - Embeds [26] Discord.js Guide - Embeds [27] Discord.js Guide - Embeds [28] Discord.js Guide - Embeds [29] Discord.js Guide - Message Components [30] Discord.js Guide - Message Components [31] Discord.js Guide - Modals [32] Discord.js Guide - Ephemeral Replies [33] Discord.js Guide - Ephemeral Replies [34] Discord.js Guide - Ephemeral Replies [35] Discord.js Guide - Modals [36] Discord.js Guide - Replying to Interactions [37] Prisma Documentation - Models [38] Prisma Documentation - Relations [39] Prisma Documentation - Scalar Types [40] Prisma Documentation - Select and Include [41] Prisma Documentation - Filtering and Pagination [42] Prisma Documentation - Prisma Migrate [43] Prisma Documentation - Connection Management [44] Prisma Documentation - Prisma Accelerate [45] Supabase Documentation - Row Level Security [46] Supabase Documentation - Auth [47] Supabase Documentation - Realtime [48] Clean Architecture by Robert C. Martin (Conceptual reference for layered architecture) [49] Unidirectional Data Flow - Wikipedia (Conceptual reference for data flow) [50] Hexagonal Architecture - Alistair Cockburn / Clean Architecture by Robert C. Martin (Conceptual references for architectural patterns) [51] SOLID Principles - Robert C. Martin (Conceptual reference for design principles) [52] Pure Functions - Wikipedia (Conceptual reference for programming paradigm) [53] Single Responsibility Principle - Wikipedia (Conceptual reference for design principle) [54] Clean Code by Robert C. Martin (Conceptual reference for coding guidelines) [55] Code Smells - Martin Fowler (Conceptual reference for software development) [56] Test-Driven Development by Kent Beck (Conceptual reference for software development) [57] Mocks Aren't Stubs - Martin Fowler (Conceptual reference for testing) [58] Unit Testing - Wikipedia (Conceptual reference for testing) [59] Integration Testing - Wikipedia (Conceptual reference for testing) [60] Code Coverage - Wikipedia (Conceptual reference for software quality) [61] vite-plugin-node GitHub Repository [62] Hot Module Replacement - Vite (Conceptual reference for Vite feature) [63] Hot Module Replacement - Vite (Conceptual reference for Vite feature) [64] Hot Module Replacement - Vite (Conceptual reference for Vite feature) [65] TSDoc Documentation [66] Standard Readme (Community standard for READMEs) [67] Architectural Decision Records (ADRs) (Conceptual reference for documentation) [68] Keep a Changelog (Community standard for changelogs)